# 高并发电梯调度系统 (Java多线程与并发控制实践)

## 1. 项目概述

这是我在Java高级编程和并发课程中，独立完成的一个高度复杂的**多线程电梯调度模拟系统**。

项目的核心是设计并实现一个能够模拟**多部电梯、实时响应乘客请求、并处理复杂调度和联动场景**的并发系统。它不仅仅是一个算法题，更是一次对**现代并发编程模型、线程同步机制和高内聚低耦合系统架构**的深度实践。

整个项目基于**生产者-消费者模型**，使用了Java的`synchronized`, `wait/notify`等多线程核心技术，从零开始构建了一个健壮、高效的并发调度系统。

---

## 2. 系统架构设计

为了处理复杂的并发交互，我将系统解耦为几个核心的、独立运行的线程角色，它们通过线程安全的共享队列进行通信。

![Architecture Diagram](link_to_your_architecture_diagram.png) 
*(强烈建议：在这里放一张简单的架构图，展示各个线程和队列之间的关系)*

*   **`PassengerFactory` 线程 (生产者):**
    *   作为系统的**唯一输入源**，它负责实时解析外部请求（包括乘客请求、调度指令、双梯联动指令），并将它们封装成对象后，放入对应的共享队列中。

*   **`Elevator` 线程 (消费者/智能体):**
    *   系统中有6个独立的`Elevator`线程，每个线程模拟一部电梯的行为。
    *   它们独立地从自己的私有请求队列中获取乘客，并根据内部的**LOOK-alike寻路策略 (`Strategy`类)** 运行。

*   **`Assigner` 线程 (中央调度器/大脑):**
    *   这是整个系统的**决策核心**。它作为乘客主队列的**唯一消费者**，负责实现复杂的**全局调度算法**。
    *   `Assigner`会实时监控所有电梯的状态（位置、方向、负载、是否处于特殊模式），并根据一套复杂的评分/决策逻辑，将乘客请求智能地分配给最合适的电梯。

*   **线程安全的共享队列 (`PassengerQueue`, `ScheduleQueue`, `UpdateQueue`):**
    *   这些队列是线程之间通信的**唯一桥梁**，是典型的**“生产者-消费者”模式中的共享缓冲区**。
    *   所有队列的`offer`和`poll`方法都使用了`synchronized`关键字来保证**原子性**和**内存可见性**，并配合`wait()/notify()`机制，实现了高效的线程间**异步协作**。

---

## 3. 核心技术实现亮点

#### **a. 精细的多线程同步与锁机制**

为了在保证线程安全的同时，最大化系统并发度，我设计并使用了**多级锁机制**：
*   **全局锁 (`bigLock`):** 用于`Assigner`与所有`Elevator`线程之间的宏观协调，例如在有特殊指令（调度/联动）需要执行时，保证整个系统状态的一致性。
*   **电梯私有锁 (`lock`):** 每个`Elevator`线程拥有一个自己的锁，用于保护其内部的私有请求队列。
*   **联动专用锁 (`smallLock`):** 在处理双电梯联动 (`Update`) 任务时，两部相关的电梯会共享一个新的`smallLock`。这把锁的粒度非常小，只用于协调它们在换乘层的同步问题，而不会阻塞系统中其他无关电梯的运行。

#### **b. 高内聚低耦合的模块化设计**

*   **策略模式 (`Strategy.java`):** 我将电梯的**寻路算法**和**双梯联动时的冲突判断逻辑**，从`Elevator`类中完全抽离出来，封装到了一个独立的`Strategy`类中。这使得电梯本身只关心“执行”，而策略类关心“决策”，是典型的**策略模式**应用，极大地提高了代码的可维护性。
*   **职责分离:** 系统中的每个核心类（`Elevator`, `Assigner`, `PassengerFactory`）都遵循**单一职责原则**，使得整个系统的逻辑非常清晰，易于理解和扩展。

#### **c. 复杂的调度与联动逻辑**

*   **动态智能调度:** `Assigner`的分配算法会综合考虑电梯的方向、负载、与乘客的距离、是否处于特殊状态等多个因素，实现了比简单“就近分配”更高效的智能调度。
*   **双电梯联动:** `processUpdate`方法中包含了整个项目最复杂的并发逻辑。它需要确保两部待联动的电梯都到达了可以被安全更新的状态，然后通过交换锁对象和`wait/notify`进行精确的同步，完成联动后再释放彼此，恢复正常运行。

---

## 4. 如何运行与项目说明

#### **a. 运行环境**
*   这是一个基于 `com.oocourse.elevator3` 官方评测包的项目。你需要将官方提供的`.jar`包正确配置到项目的依赖库中，才能编译和运行。
*   项目的主入口类是 `MainClass.java`。

#### **b. 运行方式**
1.  克隆本仓库到本地。
2.  在IDE（如IntelliJ IDEA）中将官方评测包添加为项目的外部库 (External Libraries)。
3.  运行 `MainClass.java` 的 `main` 方法。
4.  程序将从标准输入读取实时请求，并将电梯的运行日志实时输出到控制台。

#### **c. 关于 `TestMain.java` 的说明**
*   `TestMain.java` 文件**并非我所编写**，它是一个用于本地测试的辅助启动器，由大佬学长睿睿提供。
*   它的作用是读取一个带有时间戳的文本输入流，并模拟官方评测环境的实时输入行为，方便在本地进行调试和验证。
*   **我的核心工作，在于 `Elevator.java`, `Assigner.java`, `Strategy.java` 以及各个请求队列等并发调度系统的核心逻辑设计与实现。**

---
*这个项目是我对并发编程的一次深度探索。它让我真正理解了线程安全、死锁、活锁、线程协作等核心概念，并锻炼了我设计和实现一个复杂、健壮、高内聚低耦合并发系统的能力。*
